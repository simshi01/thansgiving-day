# План реализации бэкенда для сервиса благодарностей

## Требования

1. **Реальное время**: Все пользователи видят одинаковые сообщения в одном месте синхронно
2. **Хранение**: Сообщения сохраняются навсегда
3. **Валидация**: 
   - Лимит длины: 300 символов (максимум)
   - Автоматическая модерация на мат и плохие слова
4. **Стек**: Оптимальное решение для Next.js проекта

---

## Предлагаемый стек

### Backend
- **Next.js API Routes** - встроенные API эндпоинты (уже есть в проекте)
- **Socket.io** - для синхронизации в реальном времени
- **PostgreSQL** (Railway) - для хранения сообщений
- **Redis** (Railway, опционально) - для кеширования активных сообщений
- **Node.js** - уже используется в Next.js

### Платформа деплоя
- **Railway** - рекомендованная платформа
  - ✅ Бесплатный план ($5 кредитов в месяц)
  - ✅ Поддержка PostgreSQL и Redis
  - ✅ Поддержка WebSocket/Socket.io
  - ✅ Простая настройка через GitHub
  - ✅ Автоматический деплой
  - ✅ Достаточно для 100+ одновременных пользователей

### Библиотеки для модерации
- **bad-words** (расширенная версия) или
- **@coffeeandfun/google-profanity-words** + кастомный список русских слов
- Или кастомная библиотека с русским словарем мата

### Хранение данных
**PostgreSQL на Railway (рекомендуется)**
- Встроенная БД на Railway
- Бесплатный план включает PostgreSQL
- Масштабируется для 100+ пользователей
- Надежное хранение данных
- SQL запросы для эффективной работы

**Redis на Railway (опционально, для оптимизации)**
- Кеширование активных сообщений
- Быстрый доступ к данным
- Уменьшение нагрузки на PostgreSQL

---

## Архитектура решения

### 1. База данных (PostgreSQL на Railway)

**Таблица: `messages`**
```sql
CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  text TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  is_active BOOLEAN DEFAULT true,
  position_x INTEGER, -- Позиция X на экране (для синхронизации)
  position_y INTEGER, -- Позиция Y на экране (для синхронизации)
  duration REAL -- Длительность показа в секундах
);

CREATE INDEX idx_messages_created_at ON messages(created_at DESC);
CREATE INDEX idx_messages_active ON messages(is_active) WHERE is_active = true;
```

**Преимущества PostgreSQL на Railway:**
- Автоматические бэкапы
- Масштабируемость
- Надежность для 100+ пользователей
- Бесплатный план достаточен для начала

### 2. API Endpoints (Next.js API Routes)

#### `POST /api/messages` - Отправка нового сообщения
- Валидация длины (максимум 300 символов)
- Модерация текста
- Сохранение в БД
- Отправка через WebSocket всем подключенным клиентам

#### `GET /api/messages` - Получение последних сообщений
- Возвращает последние N активных сообщений
- Для начальной загрузки страницы

#### `GET /api/messages/active` - Получение активных сообщений
- Возвращает сообщения, которые сейчас показываются на экране

### 3. WebSocket сервер (Socket.io)

**События:**
- `message:new` - новое сообщение отправлено (broadcast всем)
- `message:active` - обновление списка активных сообщений
- `sync:request` - запрос синхронизации от клиента

### 4. Модерация

**Список запрещенных слов:**
- Матерные слова (полный список русских матерных слов)
- Оскорбления ("жопа", "дурак", "идиот" и т.д.)
- Негативные слова, не подходящие для благодарностей

**Реализация:**
- Проверка при отправке сообщения
- Замена на звездочки или отклонение сообщения
- Логирование попыток отправки запрещенного контента

---

## Пошаговая реализация

### Шаг 1: Установка зависимостей

```bash
npm install socket.io socket.io-client
npm install pg @types/pg  # PostgreSQL клиент
npm install --save-dev @types/bad-words
npm install bad-words
```

**Опционально (для Redis кеширования):**
```bash
npm install redis @types/redis
```

### Шаг 2: Настройка Railway

1. Создать аккаунт на railway.app
2. Подключить GitHub репозиторий
3. Создать PostgreSQL сервис (бесплатно)
4. Создать Redis сервис (опционально, бесплатно)
5. Получить connection strings из переменных окружения Railway

### Шаг 3: Настройка переменных окружения

Создать `.env.local` для локальной разработки:
```env
DATABASE_URL=postgresql://user:password@host:port/dbname
REDIS_URL=redis://host:port  # опционально
NEXT_PUBLIC_SOCKET_URL=http://localhost:3000  # для локальной разработки
```

Railway автоматически предоставит эти переменные в продакшене.

### Шаг 4: Создание утилит для работы с данными

#### `lib/db.ts` (PostgreSQL)
- Подключение к PostgreSQL через `pg`
- Функции для работы с сообщениями
- Connection pooling для эффективности

#### `lib/redis.ts` (опционально, для кеширования)
- Подключение к Redis
- Кеширование активных сообщений
- TTL для автоматической очистки

### Шаг 5: Создание API Routes

#### `app/api/messages/route.ts`
- POST: валидация, модерация, сохранение
- GET: получение сообщений

#### `app/api/messages/active/route.ts`
- GET: активные сообщения

### Шаг 6: WebSocket сервер

#### `lib/socket-server.ts`
- Настройка Socket.io сервера
- Обработка подключений
- Broadcast новых сообщений

### Шаг 7: Модерация

#### `lib/moderation.ts`
- Функция проверки текста
- Список запрещенных слов
- Обработка и замена

### Шаг 8: Интеграция с фронтендом

#### Обновление `app/page.tsx`
- Отправка сообщения через API
- Обработка успешной отправки

#### Обновление `app/messages/page.tsx`
- Подключение к WebSocket
- Получение сообщений в реальном времени
- Синхронизация позиций сообщений

#### Обновление `components/MessageContainer.tsx`
- Получение сообщений из WebSocket
- Синхронизация позиций между клиентами

---

## Детальная реализация

### Модерация текста

```typescript
// lib/moderation.ts
const forbiddenWords = [
  // Матерные слова (полный список)
  'мат1', 'мат2', 'мат3', // ... полный список
  // Плохие слова
  'жопа', 'дурак', 'идиот', 'тупой', 'дебил',
  // И т.д.
]

function moderateText(text: string): { isValid: boolean; moderatedText?: string } {
  const lowerText = text.toLowerCase()
  
  for (const word of forbiddenWords) {
    if (lowerText.includes(word)) {
      return { isValid: false }
    }
  }
  
  return { isValid: true, moderatedText: text }
}
```

### Синхронизация позиций

Для синхронизации позиций сообщений между клиентами:
- Сервер генерирует случайные позиции при создании сообщения
- Сохраняет их в БД
- Отправляет всем клиентам через WebSocket
- Все клиенты используют одинаковые позиции

### Обработка ошибок

- Валидация на клиенте (быстрая обратная связь)
- Валидация на сервере (безопасность)
- Обработка ошибок сети
- Retry логика для WebSocket

---

## Безопасность

1. **Rate Limiting**: Ограничение количества запросов от одного IP
2. **Валидация**: Проверка на клиенте и сервере
3. **Модерация**: Автоматическая фильтрация контента
4. **CORS**: Настройка для безопасности
5. **Sanitization**: Очистка HTML/JS из текста

---

## Альтернативные варианты

### Вариант 1: Supabase Realtime (проще)
- Использовать встроенный Realtime от Supabase
- Не нужен отдельный WebSocket сервер
- Проще в настройке

### Вариант 2: Firebase (Google)
- Firebase Realtime Database
- Автоматическая синхронизация
- Бесплатный план

### Вариант 3: Pusher (платный, но простой)
- Готовое решение для WebSocket
- Простая интеграция
- Есть бесплатный план

---

## Рекомендация

**Использовать Railway + PostgreSQL + Socket.io**:
- ✅ Бесплатный план ($5 кредитов в месяц)
- ✅ PostgreSQL встроен, не нужно настраивать отдельно
- ✅ Поддержка WebSocket/Socket.io из коробки
- ✅ Масштабируется для 100+ одновременных пользователей
- ✅ Автоматический деплой из GitHub
- ✅ Простая настройка через веб-интерфейс
- ✅ Переменные окружения настраиваются автоматически
- ✅ Автоматические бэкапы БД
- ✅ Мониторинг и логи встроены

**Стоимость:**
- Бесплатный план: $5 кредитов в месяц
- PostgreSQL: ~$0.01-0.02 за GB/месяц (обычно бесплатно в пределах лимита)
- Redis (опционально): бесплатно в пределах лимита
- Для 100 пользователей: скорее всего бесплатно или очень дешево (<$1/месяц)

**Альтернативы:**
- **Render** - похож на Railway, тоже бесплатный план
- **Fly.io** - бесплатный план, хорошая поддержка WebSocket
- **Heroku** - платный, но надежный

---

## Следующие шаги

1. Создать аккаунт на Railway и подключить GitHub репозиторий
2. Создать PostgreSQL сервис на Railway
3. Установить зависимости (Socket.io, pg, bad-words)
4. Настроить переменные окружения
5. Создать схему БД (SQL миграция)
6. Реализовать утилиты для работы с PostgreSQL
7. Реализовать API endpoints
8. Настроить Socket.io сервер
9. Добавить модерацию
10. Интегрировать синхронизацию в реальном времени
11. Обновить фронтенд для работы с API
12. Протестировать локально
13. Задеплоить на Railway
14. Провести нагрузочное тестирование (100 пользователей)

## Настройка Railway

### Быстрый старт:

1. **Регистрация:**
   - Зайти на railway.app
   - Войти через GitHub

2. **Создание проекта:**
   - New Project → Deploy from GitHub repo
   - Выбрать репозиторий `thanksgiving-day`

3. **Добавление PostgreSQL:**
   - New → Database → PostgreSQL
   - Railway автоматически создаст БД и добавит `DATABASE_URL` в переменные окружения

4. **Настройка деплоя:**
   - Railway автоматически определит Next.js
   - Добавит переменные окружения
   - Запустит деплой

5. **Получение URL:**
   - Railway автоматически создаст публичный URL
   - Можно настроить кастомный домен

### Переменные окружения на Railway:

Railway автоматически добавит:
- `DATABASE_URL` - для PostgreSQL
- `PORT` - порт приложения
- `RAILWAY_ENVIRONMENT` - окружение

Нужно добавить вручную:
- `NEXT_PUBLIC_SOCKET_URL` - URL для Socket.io (обычно тот же домен)

### Мониторинг:

- Railway предоставляет метрики использования
- Логи доступны в реальном времени
- Можно отслеживать использование ресурсов

---

## Вопросы для уточнения

1. Нужна ли авторизация пользователей или анонимная отправка?
2. Нужна ли возможность удаления сообщений (админ панель)?
3. Нужна ли статистика (количество сообщений, популярные слова)?
4. Как обрабатывать ошибки модерации - показывать пользователю или просто отклонять?

